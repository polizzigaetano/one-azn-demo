<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Simple Chess</title>
    <style>
      :root {
        --bg: #0f1115;
        --panel: #171a21;
        --text: #e6e6e6;
        --muted: #9aa3b2;
        --light: #f0d9b5;
        --dark: #b58863;
        --accent: #4ea1ff;
        --danger: #ff6b6b;
        --ok: #7bd88f;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .app {
        width: min(1100px, 100%);
        display: grid;
        gap: 20px;
        grid-template-columns: min(70vw, 640px) minmax(260px, 1fr);
      }

      @media (max-width: 920px) {
        .app {
          grid-template-columns: 1fr;
        }
      }

      .board {
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        overflow: hidden;
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      }

      .square {
        display: grid;
        place-items: center;
        font-size: clamp(28px, 4.4vw, 46px);
        cursor: pointer;
        user-select: none;
        position: relative;
        min-height: 0;
      }

      .square.light {
        background: var(--light);
      }

      .square.dark {
        background: var(--dark);
      }

      .square.selected {
        outline: 3px solid var(--accent);
        outline-offset: -3px;
      }

      .square.legal::after {
        content: "";
        position: absolute;
        width: 28%;
        height: 28%;
        border-radius: 50%;
        background: rgba(78, 161, 255, 0.45);
      }

      .square.capture::after {
        content: "";
        position: absolute;
        width: 80%;
        height: 80%;
        border-radius: 50%;
        border: 3px solid rgba(255, 107, 107, 0.65);
      }

      .panel {
        background: var(--panel);
        border-radius: 12px;
        padding: 18px;
        display: grid;
        gap: 14px;
        align-content: start;
        min-height: 0;
      }

      .panel h1 {
        margin: 0;
        font-size: 22px;
      }

      .status {
        font-size: 14px;
        color: var(--muted);
      }

      .status strong {
        color: var(--text);
      }

      .controls {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

      button {
        background: #222836;
        border: 1px solid #2d3342;
        color: var(--text);
        padding: 10px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        transition: 0.2s ease;
      }

      button:hover {
        border-color: var(--accent);
      }

      button:active {
        transform: translateY(1px);
      }

      .moves {
        border-top: 1px solid #2a3040;
        padding-top: 12px;
        max-height: 360px;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 13px;
      }

      .moves ol {
        padding-left: 18px;
        margin: 0;
        display: grid;
        gap: 6px;
      }

      .moves li {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      .note {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.5;
      }

      .tag {
        color: var(--ok);
        font-weight: 600;
      }

      .danger {
        color: var(--danger);
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="board" id="board" aria-label="Chess board"></div>
      <div class="panel">
        <h1>Simple Chess</h1>
        <div class="status" id="status"></div>
        <div class="controls">
          <button id="resetBtn" type="button">New Game</button>
          <button id="undoBtn" type="button">Undo</button>
          <button id="flipBtn" type="button">Flip Board</button>
        </div>
        <div class="moves">
          <ol id="moveList"></ol>
        </div>
        <div class="note">
          Local two-player chess with basic rules. Castling and en passant are
          not implemented. Pawns promote to a queen automatically.
        </div>
      </div>
    </div>

    <script>
      const boardEl = document.getElementById("board");
      const statusEl = document.getElementById("status");
      const moveListEl = document.getElementById("moveList");
      const resetBtn = document.getElementById("resetBtn");
      const undoBtn = document.getElementById("undoBtn");
      const flipBtn = document.getElementById("flipBtn");

      const PIECES = {
        w: {
          K: "♔",
          Q: "♕",
          R: "♖",
          B: "♗",
          N: "♘",
          P: "♙",
        },
        b: {
          K: "♚",
          Q: "♛",
          R: "♜",
          B: "♝",
          N: "♞",
          P: "♟︎",
        },
      };

      const FILES = "abcdefgh";
      const RANKS = "12345678";

      let state = createInitialState();

      function createInitialState() {
        return {
          board: [
            ["bR", "bN", "bB", "bQ", "bK", "bB", "bN", "bR"],
            ["bP", "bP", "bP", "bP", "bP", "bP", "bP", "bP"],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ["wP", "wP", "wP", "wP", "wP", "wP", "wP", "wP"],
            ["wR", "wN", "wB", "wQ", "wK", "wB", "wN", "wR"],
          ],
          turn: "w",
          selected: null,
          legalMoves: [],
          moveHistory: [],
          flipped: false,
          result: null,
        };
      }

      function renderBoard() {
        boardEl.innerHTML = "";
        for (let visualRow = 0; visualRow < 8; visualRow += 1) {
          for (let visualCol = 0; visualCol < 8; visualCol += 1) {
            const boardRow = state.flipped ? 7 - visualRow : visualRow;
            const boardCol = state.flipped ? 7 - visualCol : visualCol;
            const piece = state.board[boardRow][boardCol];
            const square = document.createElement("button");
            square.type = "button";
            square.className = `square ${
              (visualRow + visualCol) % 2 === 0 ? "light" : "dark"
            }`;
            square.dataset.row = boardRow;
            square.dataset.col = boardCol;
            square.setAttribute(
              "aria-label",
              `${FILES[boardCol]}${RANKS[7 - boardRow]}`
            );

            if (piece) {
              const color = piece[0];
              const type = piece[1];
              square.textContent = PIECES[color][type];
            }

            if (state.selected) {
              const { row, col } = state.selected;
              if (row === boardRow && col === boardCol) {
                square.classList.add("selected");
              }
            }

            const legal = state.legalMoves.find(
              (move) => move.to.row === boardRow && move.to.col === boardCol
            );
            if (legal) {
              square.classList.add(legal.capture ? "capture" : "legal");
            }

            square.addEventListener("click", handleSquareClick);
            boardEl.appendChild(square);
          }
        }
      }

      function handleSquareClick(event) {
        if (state.result) {
          return;
        }
        const row = Number(event.currentTarget.dataset.row);
        const col = Number(event.currentTarget.dataset.col);
        const piece = state.board[row][col];

        if (state.selected) {
          const move = state.legalMoves.find(
            (candidate) =>
              candidate.to.row === row && candidate.to.col === col
          );
          if (move) {
            applyMove(move);
            return;
          }
        }

        if (piece && piece[0] === state.turn) {
          state.selected = { row, col };
          state.legalMoves = getLegalMoves(row, col);
        } else {
          state.selected = null;
          state.legalMoves = [];
        }
        renderBoard();
        updateStatus();
      }

      function applyMove(move) {
        const { from, to, piece, capture } = move;
        const snapshot = {
          board: state.board.map((row) => row.slice()),
          turn: state.turn,
          result: state.result,
        };
        state.moveHistory.push({ snapshot, move });

        state.board[to.row][to.col] = piece;
        state.board[from.row][from.col] = null;

        if (piece[1] === "P") {
          const promotionRow = piece[0] === "w" ? 0 : 7;
          if (to.row === promotionRow) {
            state.board[to.row][to.col] = `${piece[0]}Q`;
          }
        }

        state.turn = state.turn === "w" ? "b" : "w";
        state.selected = null;
        state.legalMoves = [];
        updateGameResult();
        addMoveToHistory(move, capture);
        renderBoard();
        updateStatus();
      }

      function addMoveToHistory(move, capture) {
        const moveText = formatMove(move, capture);
        const isWhiteMove = move.piece[0] === "w";
        if (isWhiteMove) {
          const li = document.createElement("li");
          const whiteSpan = document.createElement("span");
          whiteSpan.textContent = moveText;
          const blackSpan = document.createElement("span");
          blackSpan.textContent = "";
          li.appendChild(whiteSpan);
          li.appendChild(blackSpan);
          moveListEl.appendChild(li);
        } else {
          const last = moveListEl.lastElementChild;
          if (last) {
            last.children[1].textContent = moveText;
          }
        }
        moveListEl.scrollTop = moveListEl.scrollHeight;
      }

      function formatMove(move, capture) {
        const piece = move.piece[1];
        const pieceLabel = piece === "P" ? "" : piece;
        const captureMark = capture ? "x" : "";
        const to = `${FILES[move.to.col]}${RANKS[7 - move.to.row]}`;
        const promotion =
          move.piece[1] === "P" && (move.to.row === 0 || move.to.row === 7)
            ? "=Q"
            : "";
        return `${pieceLabel}${captureMark}${to}${promotion}`;
      }

      function updateStatus() {
        const turnLabel = state.turn === "w" ? "White" : "Black";
        const inCheck = isInCheck(state.turn, state.board);
        let message = `Turn: <strong>${turnLabel}</strong>`;
        if (inCheck) {
          message += ` — <span class="danger">Check</span>`;
        }
        if (state.result) {
          message = state.result;
        }
        statusEl.innerHTML = message;
        undoBtn.disabled = state.moveHistory.length === 0;
      }

      function updateGameResult() {
        const hasMoves = playerHasLegalMove(state.turn, state.board);
        if (!hasMoves) {
          const inCheck = isInCheck(state.turn, state.board);
          if (inCheck) {
            const winner = state.turn === "w" ? "Black" : "White";
            state.result = `<span class="tag">${winner} wins</span> — Checkmate`;
          } else {
            state.result = `<span class="tag">Draw</span> — Stalemate`;
          }
        } else {
          state.result = null;
        }
      }

      function playerHasLegalMove(color, board) {
        for (let row = 0; row < 8; row += 1) {
          for (let col = 0; col < 8; col += 1) {
            const piece = board[row][col];
            if (piece && piece[0] === color) {
              const moves = getLegalMoves(row, col, board, color, true);
              if (moves.length > 0) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function getLegalMoves(row, col, board = state.board, color = state.turn, skipTurnCheck = false) {
        const piece = board[row][col];
        if (!piece || (!skipTurnCheck && piece[0] !== color)) {
          return [];
        }
        const pseudoMoves = getPseudoMoves(row, col, board);
        return pseudoMoves.filter((move) => {
          const cloned = board.map((r) => r.slice());
          cloned[move.to.row][move.to.col] = piece;
          cloned[row][col] = null;
          return !isInCheck(piece[0], cloned);
        });
      }

      function getPseudoMoves(row, col, board) {
        const piece = board[row][col];
        const color = piece[0];
        const type = piece[1];
        const moves = [];
        const forward = color === "w" ? -1 : 1;

        const addMove = (r, c) => {
          if (r < 0 || r > 7 || c < 0 || c > 7) {
            return;
          }
          const target = board[r][c];
          if (!target || target[0] !== color) {
            moves.push({
              from: { row, col },
              to: { row: r, col: c },
              piece,
              capture: Boolean(target),
            });
          }
        };

        if (type === "P") {
          const one = row + forward;
          if (board[one] && !board[one][col]) {
            addMove(one, col);
            const startRow = color === "w" ? 6 : 1;
            const two = row + forward * 2;
            if (row === startRow && board[two] && !board[two][col]) {
              addMove(two, col);
            }
          }
          [col - 1, col + 1].forEach((c) => {
            if (board[one] && board[one][c] && board[one][c][0] !== color) {
              addMove(one, c);
            }
          });
          return moves;
        }

        if (type === "N") {
          const offsets = [
            [-2, -1],
            [-2, 1],
            [-1, -2],
            [-1, 2],
            [1, -2],
            [1, 2],
            [2, -1],
            [2, 1],
          ];
          offsets.forEach(([dr, dc]) => addMove(row + dr, col + dc));
          return moves;
        }

        if (type === "K") {
          for (let dr = -1; dr <= 1; dr += 1) {
            for (let dc = -1; dc <= 1; dc += 1) {
              if (dr !== 0 || dc !== 0) {
                addMove(row + dr, col + dc);
              }
            }
          }
          return moves;
        }

        const directions = [];
        if (type === "B" || type === "Q") {
          directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]);
        }
        if (type === "R" || type === "Q") {
          directions.push([-1, 0], [1, 0], [0, -1], [0, 1]);
        }

        directions.forEach(([dr, dc]) => {
          let r = row + dr;
          let c = col + dc;
          while (r >= 0 && r <= 7 && c >= 0 && c <= 7) {
            const target = board[r][c];
            if (!target) {
              addMove(r, c);
            } else {
              if (target[0] !== color) {
                addMove(r, c);
              }
              break;
            }
            r += dr;
            c += dc;
          }
        });
        return moves;
      }

      function isInCheck(color, board) {
        let kingPosition = null;
        for (let row = 0; row < 8; row += 1) {
          for (let col = 0; col < 8; col += 1) {
            if (board[row][col] === `${color}K`) {
              kingPosition = { row, col };
              break;
            }
          }
          if (kingPosition) {
            break;
          }
        }
        if (!kingPosition) {
          return false;
        }
        const opponent = color === "w" ? "b" : "w";
        for (let row = 0; row < 8; row += 1) {
          for (let col = 0; col < 8; col += 1) {
            const piece = board[row][col];
            if (piece && piece[0] === opponent) {
              const moves = getPseudoMoves(row, col, board);
              if (
                moves.some(
                  (move) =>
                    move.to.row === kingPosition.row &&
                    move.to.col === kingPosition.col
                )
              ) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function resetGame() {
        state = createInitialState();
        moveListEl.innerHTML = "";
        renderBoard();
        updateStatus();
      }

      function undoMove() {
        const last = state.moveHistory.pop();
        if (!last) {
          return;
        }
        state.board = last.snapshot.board.map((row) => row.slice());
        state.turn = last.snapshot.turn;
        state.result = last.snapshot.result;
        state.selected = null;
        state.legalMoves = [];
        moveListEl.innerHTML = "";
        state.moveHistory.forEach(({ move }) => addMoveToHistory(move, move.capture));
        renderBoard();
        updateStatus();
      }

      resetBtn.addEventListener("click", resetGame);
      undoBtn.addEventListener("click", undoMove);
      flipBtn.addEventListener("click", () => {
        state.flipped = !state.flipped;
        renderBoard();
      });

      renderBoard();
      updateStatus();
    </script>
  </body>
</html>
